## 解析について

- スロークエリをpt-query-digestにかませるのが良い。

## Explain

- keyで使われているキー
- key_lenでマルチカラムインデックスの場合に使われるキーの長さ
- refは結合するときに内部表を検索するカラム

## JOINについて

- MySQLはNstedLoopのみ対応。
- NLPはいわば二重forループなので、nの数を減らすと早くなる。
    - 駆動表が小さく、かつ内部表(内側for文)が早く計算できるのが一番はやい。
    - つまり外部表が小さく、内部表がインデックスで検索できるのが最速。
    - 外部表がでかくて内部表が小さくても外部表はインデックススキャン関係ないからNの数だけスキャンが走ってあまり早くならない。

## マルチカラムインデックスについて

- 100-001 100-002 101-001 101-002 101-003のようになる。順番が重要。カーディナリティが高いものを先においたほうが良い。
- 範囲検索の場合100と101にまたがると001、002がループするため範囲検索とソートが入るとインデックスがきかない
- IN句を使っても連番にならないとインデックスはきかない
- DATE関数を使う場合はインデックスがきかない
- レンジ検索で範囲が広すぎるとインデックスがきかない
- JOINは内部表に対しての検索が走るため、外部表のインデックスは関係ない。

## クエリキャッシュ

- 同じクエリが発行された際にキャッシュ領域から結果を取得してくるための仕組み。
    - テーブルが更新されたらフラッシュされる。
- ログインサービスは個人向けクエリが多いため、マスターキャッシュ以外は意味がなさそうだが、
  管理画面やバッチなどアカウント指定でなく特定条件のものをすべてひいてくるようなケースだと有効そう
